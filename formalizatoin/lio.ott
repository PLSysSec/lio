metavar x ::=   {{ com  term variable }} 
                {{ lex alphanum }} 


metavar a ::= {{ com memory location }}
              {{ lex alphanum }} 

indexvar i ::= {{ com integer }}

indexvar n ::= {{ com integer }}

grammar

l, c :: 'l_' ::=                                {{ com label                 }}
  | lubPrim l l' ::   :: VLub                   {{ com primitive label join  }}
                                                {{ tex [[l]] \sqcup_p [[l']] }}

v :: 'v_' ::=                                   {{ com value                 }}
  | true         ::   :: VTrue                  {{ com Boolean true          }}
  | false        ::   :: VFalse                 {{ com Boolean false         }}
  | ()           ::   :: VUnit                  {{ com unit value            }}
  | l            ::   :: VLabel                 {{ com label                 }}
  | Loc T        :: M :: VAddress               {{ com address               }}
                                                {{ tex a^[[T]]_\ell          }}
  | x            ::   :: VVar                   {{ com variable              }}
  | \ x . t      ::   :: VLam                   {{ com lambda                }}
  | ( t1 , t2 )  ::   :: VTuple                 {{ com tuple                 }}
  | fix t        ::   :: VFix                   {{ com fixpoint              }}
  | Lb t1 t2     :: M :: VLabeled               {{ com labeled               }}
  | LIO t        :: M :: VLIOVal                {{ com LIO value             }}
                                                {{ tex ([[t]])^{[[LIO]]_\ell}   }}
                                                                             
t :: 't_'  ::=                                  {{ com term                  }}
  | true         ::   :: VTrue                  {{ com Boolean true          }}
  | false        ::   :: VFalse                 {{ com Boolean false         }}
  | ()           ::   :: VUnit                  {{ com unit value            }}
  | l            ::   :: VLabel                 {{ com label                 }}
  | Loc T        :: M :: VAddress               {{ com address               }}
                                                {{ tex a^[[T]]_\ell          }}
  | x            ::   :: VVar                   {{ com variable              }}
  | \ x . t      ::   :: VLam (+ bind x in t +) {{ com lambda                }}
  | ( t1 , t2 )  ::   :: VTuple                 {{ com tuple                 }}
  | fix t        ::   :: VFix                   {{ com fixpoint              }}
  | Lb t1 t2     :: M :: VLabeled               {{ com labeled               }}
  | LIO t        :: M :: VLIOVal                {{ com LIO value             }}
                                                {{ tex ([[t]])^{[[LIO]]_\ell}   }}

  | t t'                  ::   :: App           {{ com app                   }}
  | proj i  t             ::   :: Proj          {{ com proj                  }}
                                                {{ tex \pi_[[i]] [[t]]       }}
  | if t1 then t2 else t3 ::   :: IfEl          {{ com conditional           }}
  | let x = t in t'       ::   :: Let           (+ bind x in t               +)
                                                (+ bind x in t'              +)
                                                {{ com let                   }}
  | return t              ::   :: Return        {{ com return                }}
                                               {{ tex [[return]]_\ell\ [[t]] }}
  | bind t t'             ::   :: Bind          {{ com bind                  }}
                                        {{ tex [[t]] >\!\!>\!\!=_\ell [[t']] }}
  | label t t'            ::   :: Label         {{ com label                 }}
  | unlabel t             ::   :: UnLabel       {{ com unlabel               }}
  | toLabeled t1 t2       ::   :: ToLabeled     {{ com execute action        }}
  | newLIORef t1 t2       ::   :: NewLIORef     {{ com new reference         }}
  | readLIORef t1         ::   :: ReadLIORef    {{ com read reference        }}
  | writeLIORef t1 t2     ::   :: WriteLIORef   {{ com write reference       }}
  | lowerClr t            ::   :: LowerClr      {{ com lower clearance       }}
  | getLabel              ::   :: GetLabel      {{ com get current label     }}
                                                {{ tex [[getLabel]]_\ell     }}
  | getClearance          ::   :: GetClearance  {{ com get current clearance }}
                                                {{ tex [[getClearance]]_\ell }}
  | labelOf t             ::   :: LabelOf       {{ com get label of value    }}
  | lub t1 t2             ::   :: Join          {{ com least upper bound     }}
                                                {{ tex [[t1]] \sqcup [[t2]] }}
  | ( t )                 :: S :: Paren         {{ icho [[t]]                }} 
  | { t / x } t'          :: M :: Tsub        
                                      {{ icho (tsubst_t [[t]] [[x]] [[t']]) }}

M {{ tex \phi }} :: 'M_'  ::=                   {{ com memory                }}
   | mem_empty            ::   :: MemEmpty      {{ com empty set             }}
                                                {{ tex \emptyset             }}
   | M , ( t , t' )       ::   :: ConcatElem    {{ com element addition      }}
   | update M t t'        ::   :: Update        {{ com memory update         }}
                                       {{ tex [[M]] [ [[t]] \mapsto [[t']] ] }}

p :: 'p_'  ::=                                  {{ com program               }}
  | <| l , c , M , t |>   ::   :: Program       {{ com environment and term  }}


T {{ tex \tau }} :: T_ ::=                      {{ com type                  }}
  | Bool                ::   :: TBool           {{ com Booleans              }}
  | ()                  ::   :: TUnit           {{ com unit                  }}
  | Label               ::   :: TLabel          {{ com label }} {{tex \ell   }}
  | T -> T'             ::   :: TArrow          {{ com function              }}
  | ( T , T' )          ::   :: TProduct        {{ com product               }}
  | Labeled T           :: S :: TLabeled        {{ com Labeled value         }}
                                              {{ tex [[Labeled]]_\ell\ [[T]] }}
  | LIORef T            :: S :: TLIORef         {{ com Reference             }}
                                               {{ tex [[LIORef]]_\ell\ [[T]] }}
  | LIO T               :: S :: TLIO            {{ com LIO action            }}
                                                {{ tex [[LIO]]_\ell\ [[T]]   }}
  | ( T )               :: S :: TParen          {{ ich [[T]] }} {{ ocaml int }}

G {{ tex \Gamma }} :: G_ ::=                    {{ com type environment      }}
  | tenv_empty          ::   :: TyEmpty         {{ tex \emptyset             }}
  | G , x : T           ::   :: ConcatType

formula :: 'formula_' ::=          
  | judgement           ::   :: judgement
  | [| formula |]       ::   :: denotational
  | x = x'              ::   :: eqvx
  | t = t'              ::   :: eqvt
  | M = M'              ::   :: eqvM
  | l = l'              ::   :: eqvl
  | l [= l'             ::   :: canFlowTo
  | elem ( t , t' ) M   ::   :: atInM       {{ tex ([[t]], [[t']]) \in [[M]] }}
  | x : T inT G         ::   :: xTG
  | fresh t             ::   :: aFresh       {{ tex [[t]]\ \mathit{fresh}    }}

terminals :: 'terminals_' ::=
  | \            ::  :: lambda   {{ tex \lambda                              }}
  | -->          ::  :: reduce   {{ tex \longrightarrow                      }}
  | ->           ::  :: arrow    {{ tex \to                                  }}
  | =>           ::  :: bigstep  {{ tex \longrightarrow^*                    }}
  | ~>           ::  :: preduce  {{ tex \leadsto                             }}
  | <|           ::  :: langle   {{ tex \langle                              }}
  | |>           ::  :: rangle   {{ tex \rangle                              }}
  | [=           ::  :: leq      {{ tex \sqsubseteq                          }}
  | [|           ::  :: llbacket {{ tex [\![                                 }}
  | |]           ::  :: rrbacket {{ tex ]\!]                                 }}
  | |-           ::  :: vdash    {{ tex \vdash                               }}
  | inT          ::  :: in       {{ tex \in                                  }}

subrules
  v <:: t

defns
  Jtype :: '' ::= 

defn
    G |- t : T :: :: typeinf :: T_ by

    -------------------------- :: true
    tenv_empty |- true : Bool

    -------------------------- :: false
    tenv_empty |- false : Bool

    -------------------------- :: unit
    tenv_empty |- () : ()

    -------------------------- :: labels1
    tenv_empty |- l  : Label  

    -------------------------- :: labels2
    tenv_empty |- c  : Label  

    ----------------------------- :: addr
    tenv_empty |- Loc T: LIORef T

    x:T inT G
    ----------- :: valName
    G |- x:T

    G , x : T1  |- t : T2
    -------------------- :: abs
    G |- \x.t : T1 -> T2

    G |- t1 : T1
    G |- t2 : T2 
    ------------------------ :: tuple
    G |- (t1, t2) : (T1, T2)

    G |- t : T -> T
    --------------- :: fix
    G |- fix t : T

    G |- t1 : Label
    G |- t : T2
    ----------------------------- :: labeledVal
    G |- Lb t1 t2 : Labeled T2

    G |- t : T
    ------------------------ :: lioVal
    G |- LIO t : LIO T

    G |- t  : T1 -> T2
    G |- t' : T1 
    ---------------- :: app
    G |- t t' : T2

    G |- t : (T1, T2)
    ----------------- :: proj
    G |- proj i t : Ti

    G |- t1 : Bool
    G |- t2 : T
    G |- t3 : T
    ------------------------------ :: ifEl
    G |- if t1 then t2 else t3 : T

    G |- t1 : T1
    G , x : T1  |- t2 : T2
    --------------------------- :: let
    G |- let x = t1 in t2 : T2

    G |- t : T
    --------------------- :: return
    G |- return t : LIO T

    G |- t  : LIO T1
    G |- t' : T1 -> LIO T2
    ------------------------ :: bind
    G |- bind t t' : LIO T2

    G |- t  : Label
    G |- t' : T
    --------------------------------- :: label
    G |- label t t' : LIO (Labeled T)

    G |- t : Labeled T
    ---------------------- :: unlabel
    G |- unlabel t : LIO T

    G |- t1 : Label
    G |- t2 : LIO T
    -------------------------------------- :: toLabeled
    G |- toLabeled t1 t2 : LIO (Labeled T)

    G |- t1 : Label
    G |- t2 : T
    ------------------------------------- :: newLIORef
    G |- newLIORef t1 t2 : LIO (LIORef T)

    G |- t : LIORef T
    ------------------------- :: readLIORef
    G |- readLIORef t : LIO T

    G |- t1 : LIORef T
    G |- t2 : T
    ------------------------------- :: writeLIORef
    G |- writeLIORef t1 t2 : LIO ()

    G |- t : Label
    ------------------------:: lowerClr
    G |- lowerClr t : LIO ()

    ---------------------------------- :: getLabel
    tenv_empty |- getLabel : LIO Label

    ---------------------------------- :: getClearance
    tenv_empty |- getClearance : LIO Label

    G |- t : Labeled T
    ---------------------- :: labelOf
    G |- labelOf t : Label

    G |- t1 : Label
    G |- t2 : Label
    ---------------------- :: join
    G |- lub t1 t2 : Label


defns
  Jop :: '' ::=

defn
 p1 => p2 :: ::bigstep::''  {{ com [[p1]] takes big step reduces to [[p2]]}} by

    <| l, c, M, t |> --> <| l', c', M', t' |>
    ------------------------------------------ :: onestep
    <| l, c, M, t |> => <| l', c', M', t' |>


    ------------------------------------ :: done
    <| l, c, M, v |> => <| l, c, M, v |>
    

defn
 t1 ~> t2 :: ::preduce:: P_ {{ com pure [[t1]] reduces to [[t2]]}} by



    t1 ~> t1'
    ------------- :: appCtx
    t1 t ~> t1' t

    -----------------------  :: app
    (\x.t1) t2 ~>  {t2/x}t1

    ------------------ :: fix
    fix t ~> t (fix t)

    t ~> t'
    --------------------- :: projCtx
    proj i t ~> proj i t'

    ---------------------- :: proj
    proj i (t1 , t2) ~> ti

    t1 ~> t1'
    ------------------------------------------------  :: ifCtx
    if t1 then t2 else t3 ~> if t1' then t2 else t3

    ------------------------------  :: ifTrue
    if true then t2 else t3 ~> t2

    -------------------------------  :: ifFalse
    if false then t2 else t3 ~> t3

    -----------------------------  :: let
    let x = t1 in t2 ~> {t1/x}t2

    t1 ~> t1'
    ------------------------  :: lubCtxL
    lub t1 t2 ~> lub t1' t2

    t2 ~> t2'
    -----------------------  :: lubCtxR
    lub l1 t2 ~> lub l1 t2'

    --------------------------  :: lub
    lub l1 l2 ~> lubPrim l1 l2

    t ~> t'
    -------------------------------------------------------------------- :: labelOfCtx1
    labelOf t ~> labelOf t'

    t1 ~> t1'
    -------------------------------------------------------------------- :: labelOfCtx2
    labelOf (Lb t1 t2) ~> labelOf (Lb t1' t2)

    --------------------------------------------------  :: labelOf
    labelOf (Lb l1 t2) ~> l1



defn
 p1 --> p2 :: ::reduce:: E_ {{ com [[p1]] reduces to [[p2]]}} by

    ----------------------------------------------  :: return
    <|l, c, M, return t |> --> <|l, c, M, LIO t |>

    <|l, c, M, t1|> --> <|l', c', M', t1'|>
    ------------------------------------------------------  :: bindCtx
    <|l, c, M, bind t1 t2|> --> <|l', c', M', bind t1' t2|>

    ----------------------------------------------------  :: bind
    <|l, c, M, bind (LIO t1) t2|> --> <|l, c, M, t2 t1|>


    t1 ~> t1'
    ------------------------------------------------------  :: labelCtx
    <|l, c, M, label t1 t2|> --> <|l, c, M, label t1' t2|>

    l  [= l1
    l1 [= c    
    -----------------------------------------------------------  :: label
    <|l, c, M, label l1 t2|> --> <|l, c, M, return (Lb l1 t2)|>

    t ~> t'
    --------------------------------------------------  :: unlabelCtx1
    <|l, c, M, unlabel t|> --> <|l, c, M, unlabel t'|>

    t1 ~> t1'
    -------------------------------------------------------------------- :: unlabelCtx2
    <|l, c, M, unlabel (Lb t1 t2)|> --> <|l, c, M, unlabel (Lb t1' t2)|>

    lub l l1 ~> l2
    l2 [= c
    ---------------------------------------------------------  :: unlabel
    <|l, c, M, unlabel (Lb l1 t2)|> --> <|l2, c, M, return t2|>

    t1 ~> t1'
    -------------------------------------------------------------- :: toLabeledCtx
    <|l, c, M, toLabeled t1 t2|> --> <|l, c, M, toLabeled t1' t2|>

    l  [= l1
    l1 [= c
    <|l, c, M, t|> => <|l', c', M', return t'|>
    l' [= l1
    -------------------------------------------------------------- :: toLabeled
    <|l, c, M, toLabeled l1 t|> --> <|l, c, M', label l1 t'|>

    t1 ~> t1'
    --------------------------------------------------------------  :: newLIORefCtx
    <|l, c, M, newLIORef t1 t2|> --> <|l, c, M, newLIORef t1' t2|>

    l [= l1
    l1 [= c
    fresh Loc T
    M' = M , (Loc T, Lb l1 t2)
    G |- Lb l1 t2 : Labeled T
    ------------------------------------------------------  :: newLIORef
    <|l, c, M, newLIORef l1 t2|> --> <|l, c, M', return (Loc T) |>

    t ~> t'
    -------------------------------------------------------  :: readLIORefCtx
    <|l, c, M, readLIORef t|> --> <|l, c, M, readLIORef t'|>

    elem (Loc T, Lb l1 t2) M
    lub l l1 ~> l' 
    l' [= c
    ----------------------------------------------------  :: readLIORef
    <|l, c, M, readLIORef (Loc T)|> --> <|l', c, M, return t2|>

    t1 ~> t1'
    ------------------------------------------------------------------  :: writeLIORefCtx
    <|l, c, M, writeLIORef t1 t2|> --> <|l, c, M, writeLIORef t1' t2|>

    elem (Loc T, Lb l1 t2) M
    lub l l1 ~> l' 
    l' [= c
    M' = update M Loc T Lb l1 t2'
    ---------------------------------------------------------  :: writeLIORef
    <|l, c, M, writeLIORef (Loc T) t2'|> --> <|l', c, M', return ()|>
  
    t ~> t'
    -----------------------------------------------------  :: lowerClrCtx
    <|l, c, M, lowerClr t |> -->  <|l, c, M, lowerClr t'|>

    l  [= c'
    c' [= c
    -----------------------------------------------------  :: lowerClr
    <|l, c, M, lowerClr c'|> -->  <|l, c', M, return ()|>

    ------------------------------------------------  :: getLabel
    <|l, c, M, getLabel|> -->  <|l, c, M, return l|>

    ----------------------------------------------------  :: getClearance
    <|l, c, M, getClearance|> -->  <|l, c, M, return c|>
